<!DOCTYPE html>
<html lang="en">
  <head>
    <title>BoKu - Dev Duck</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ¦†</text></svg>">
    <style>
      body {
       background: #050a0e;
       overflow: hidden;
      }
      
      #container {
        position: absolute;
        width: 1000px;
        height: 1000px;
        margin: auto;
        transform: rotate(45deg);
        top: 0; bottom: 0; left: 0; right: 0;
      }
    </style>
  </head>
  <body>
    <div id="gh" style="display:flex; color:#f0f6fc;">
      <div class="left" style="display:flex;">
        <div><svg height="32" aria-hidden="true" viewBox="0 0 24 24" version="1.1" width="32" data-view-component="true" class="octicon octicon-mark-github v-align-middle">
    <path fill="white" d="M12 1C5.923 1 1 5.923 1 12c0 4.867 3.149 8.979 7.521 10.436.55.096.756-.233.756-.522 0-.262-.013-1.128-.013-2.049-2.764.509-3.479-.674-3.699-1.292-.124-.317-.66-1.293-1.127-1.554-.385-.207-.936-.715-.014-.729.866-.014 1.485.797 1.691 1.128.99 1.663 2.571 1.196 3.204.907.096-.715.385-1.196.701-1.471-2.448-.275-5.005-1.224-5.005-5.432 0-1.196.426-2.186 1.128-2.956-.111-.275-.496-1.402.11-2.915 0 0 .921-.288 3.024 1.128a10.193 10.193 0 0 1 2.75-.371c.936 0 1.871.123 2.75.371 2.104-1.43 3.025-1.128 3.025-1.128.605 1.513.221 2.64.111 2.915.701.77 1.127 1.747 1.127 2.956 0 4.222-2.571 5.157-5.019 5.432.399.344.743 1.004.743 2.035 0 1.471-.014 2.654-.014 3.025 0 .289.206.632.756.522C19.851 20.979 23 16.854 23 12c0-6.077-4.922-11-11-11Z"></path>
</svg>
        </div>
        <div>BoKu</div>
        <div>/</div>
        <div>boku.github.io</div>
      </div>
      <div class="right">
        
      </div>
    </div>
    <canvas id="container" width="1000" height="1000"></canvas>
  
    <script src="requestAnimationFrame.js"></script>
      <script>
var points = [],
    velocity2 = 5, // velocity squared
    canvas = document.getElementById('container'),
    context = canvas.getContext('2d'),
    radius = 5,
    boundaryX = 1000,
    boundaryY = 1000,
    numberOfPoints = 69,
    labels = ['B','o','K','u']; // letters to attach to points

// visual settings you can tweak:
var fontSize = 8;         // label font size in px
var labelPadding = 4;      // horizontal padding (px) around the label inside the circle
var lineColor = '#8BDA9F'; // connection line color
var lineWidth = 1;         // connection line width

init();

function init() {
  // create most points (leave room for labeled points)
  var randomPoints = numberOfPoints - labels.length;
  for (var i = 0; i < randomPoints; i++) {
    createPoint();
  }

  // create labeled points positioned roughly across the center so they look like a name
  var startX = boundaryX/2 - 90;
  var gap = 60;
  for (var j = 0; j < labels.length; j++) {
    createPoint({
      x: startX + j * gap,
      y: boundaryY/2,
      char: labels[j]
    });
  }

  // create connections (circular chain)
  for (var i = 0, l = points.length; i < l; i++) {
    if (i === 0) {
      points[i].buddy = points[points.length - 1];
    } else {
      points[i].buddy = points[i - 1];
    }
  }
  
  // set canvas text style defaults
  context.textAlign = 'center';
  context.textBaseline = 'middle';
  context.font = 'bold ' + fontSize + 'px sans-serif';
  
  // animate
  animate();
}

function createPoint(opts) {
  opts = opts || {};
  var point = {}, vx2, vy2;
  point.x = (typeof opts.x === 'number') ? opts.x : Math.random() * boundaryX;
  point.y = (typeof opts.y === 'number') ? opts.y : Math.random() * boundaryY;

  // random vx: use Math.floor(Math.random()*2) to get 0 or 1
  var sign = (Math.floor(Math.random() * 2) * 2 - 1); // -1 or 1
  point.vx = sign * Math.random();
  vx2 = Math.pow(point.vx, 2);
  // vy^2 = velocity^2 - vx^2 (ensure non-negative)
  vy2 = Math.max(0, velocity2 - vx2);
  point.vy = Math.sqrt(vy2) * ((Math.random() * 2) - 1);

  if (opts.char) {
    point.char = opts.char;
    // initial radius; final computed in draw() to match text + padding
    point.radius = radius;
  } else {
    point.radius = radius;
  }

  points.push(point);
}

function resetVelocity(point, axis, dir) {
  var vx, vy, vx2, vy2;
  if(axis == 'x') {
    point.vx = dir * Math.random();  
    vx2 = Math.pow(point.vx, 2);
    // vy^2 = velocity^2 - vx^2
    vy2 = Math.max(0, velocity2 - vx2);
    point.vy = Math.sqrt(vy2) * (Math.random()*2-1);
  } else {
    point.vy = dir * Math.random();  
    vy2 = Math.pow(point.vy, 2);
    // vx^2 = velocity^2 - vy^2
    vx2 = Math.max(0, velocity2 - vy2);
    point.vx = Math.sqrt(vx2) * (Math.random()*2-1);
  }
}

function drawCircle(x, y, r, isLabel) {
  context.beginPath();
  context.arc(x, y, r, 0, 2 * Math.PI, false);
  context.fillStyle = isLabel ? '#ffffff' : '#1E963C';
  context.fill();  
  if (isLabel) {
    // subtle stroke to separate white circle from background/lines
    context.lineWidth = 1;
    context.strokeStyle = '#050a0e';
    context.stroke();
  }
}

function drawLine(x1, y1, x2, y2) {
  context.beginPath();
  context.moveTo(x1, y1);
  context.lineTo(x2, y2);
  context.strokeStyle = lineColor;
  context.lineWidth = lineWidth;
  context.stroke();
}  

function draw() {
  // ensure font is set before measuring text
  context.font = 'bold ' + fontSize + 'px sans-serif';

  // 1) update positions
  for(var i = 0, l = points.length; i < l; i++) {
    var point = points[i];
    point.x += point.vx;
    point.y += point.vy;
  }

  // 2) compute radii for labeled points so collisions respect the padded size
  for(var i = 0, l = points.length; i < l; i++) {
    var point = points[i];
    if (point.char) {
      var metrics = context.measureText(point.char);
      var textWidth = metrics.width;
      // radius to fit text width or font size vertically, plus padding
      var computedRadius = Math.max(radius, Math.max(textWidth, fontSize) / 2 + labelPadding);
      point.radius = computedRadius;
    } else {
      point.radius = radius;
    }

    // check for edge collisions (bounce) using the computed radius
    if(point.x < 0 + point.radius) {
      point.x = point.radius;
      resetVelocity(point, 'x', 1);
    } else if(point.x > boundaryX - point.radius) {
      point.x = boundaryX - point.radius;
      resetVelocity(point, 'x', -1);
    }
    if(point.y < 0 + point.radius) {
      point.y = point.radius;
      resetVelocity(point, 'y', 1);
    } else if(point.y > boundaryY - point.radius) {
      point.y = boundaryY - point.radius;
      resetVelocity(point, 'y', -1);
    }
  }

  // 3) draw all connecting lines first so they appear behind circles
  for(var i = 0, l = points.length; i < l; i++) {
    var point = points[i];
    if (point.buddy) {
      drawLine(point.x, point.y, point.buddy.x, point.buddy.y);
    }
  }

  // 4) draw circles and labels on top
  for(var i = 0, l = points.length; i < l; i++) {
    var point = points[i];
    var isLabel = !!point.char;

    drawCircle(point.x, point.y, point.radius, isLabel);

    // draw letter if present
    if (point.char) {
      context.fillStyle = '#102131'; // darker fill so letter is visible over white circle
      context.fillText(point.char, point.x, point.y + 1); // slight vertical tweak
    }
  }
}

function animate() {
  context.clearRect(0, 0, boundaryX, boundaryY);
  draw();
  requestAnimationFrame(animate);
}
  </script>
  </body>
</html>
