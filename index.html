<!DOCTYPE html>
<html lang="en">
  <head>
    <title>BoKu - Dev Duck</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ¦†</text></svg>">
    <style>
      body {
       background: #050a0e;
       overflow: hidden;
      }
      
      #container {
        position: absolute;
        width: 500px;
        height: 500px;
        margin: auto;
        transform: rotate(45deg);
        top: 0; bottom: 0; left: 0; right: 0;
      }
    </style>
  </head>
  <body>
    <canvas id="container" width="500" height="500"></canvas>
  
    <script src="requestAnimationFrame.js"></script>
      <script>
var points = [],
    velocity2 = 5, // velocity squared
    canvas = document.getElementById('container'),
    context = canvas.getContext('2d'),
    radius = 5,
    boundaryX = 500,
    boundaryY = 500,
    numberOfPoints = 69,
    labels = ['B','o','K','u']; // letters to attach to points

// visual settings you can tweak:
var fontSize = 12;         // label font size in px
var labelPadding = 6;      // horizontal padding (px) around the label inside the circle
var lineColor = '#8BDA9F'; // connection line color
var lineWidth = 1;         // connection line width

init();

function init() {
  // create most points (leave room for labeled points)
  var randomPoints = numberOfPoints - labels.length;
  for (var i = 0; i < randomPoints; i++) {
    createPoint();
  }

  // create labeled points positioned roughly across the center so they look like a name
  var startX = boundaryX/2 - 90;
  var gap = 60;
  for (var j = 0; j < labels.length; j++) {
    createPoint({
      x: startX + j * gap,
      y: boundaryY/2,
      char: labels[j]
    });
  }

  // create connections (circular chain)
  for (var i = 0, l = points.length; i < l; i++) {
    if (i === 0) {
      points[i].buddy = points[points.length - 1];
    } else {
      points[i].buddy = points[i - 1];
    }
  }
  
  // set canvas text style defaults
  context.textAlign = 'center';
  context.textBaseline = 'middle';
  context.font = 'bold ' + fontSize + 'px sans-serif';
  
  // animate
  animate();
}

function createPoint(opts) {
  opts = opts || {};
  var point = {}, vx2, vy2;
  point.x = (typeof opts.x === 'number') ? opts.x : Math.random() * boundaryX;
  point.y = (typeof opts.y === 'number') ? opts.y : Math.random() * boundaryY;

  // random vx: use Math.floor(Math.random()*2) to get 0 or 1
  var sign = (Math.floor(Math.random() * 2) * 2 - 1); // -1 or 1
  point.vx = sign * Math.random();
  vx2 = Math.pow(point.vx, 2);
  // vy^2 = velocity^2 - vx^2 (ensure non-negative)
  vy2 = Math.max(0, velocity2 - vx2);
  point.vy = Math.sqrt(vy2) * ((Math.random() * 2) - 1);

  if (opts.char) {
    point.char = opts.char;
    // initial radius; final computed in draw() to match text + padding
    point.radius = radius;
  } else {
    point.radius = radius;
  }

  points.push(point);
}

function resetVelocity(point, axis, dir) {
  var vx, vy, vx2, vy2;
  if(axis == 'x') {
    point.vx = dir * Math.random();  
    vx2 = Math.pow(point.vx, 2);
    // vy^2 = velocity^2 - vx^2
    vy2 = Math.max(0, velocity2 - vx2);
    point.vy = Math.sqrt(vy2) * (Math.random()*2-1);
  } else {
    point.vy = dir * Math.random();  
    vy2 = Math.pow(point.vy, 2);
    // vx^2 = velocity^2 - vy^2
    vx2 = Math.max(0, velocity2 - vy2);
    point.vx = Math.sqrt(vx2) * (Math.random()*2-1);
  }
}

function drawCircle(x, y, r, isLabel) {
  context.beginPath();
  context.arc(x, y, r, 0, 2 * Math.PI, false);
  context.fillStyle = isLabel ? '#ffffff' : '#1E963C';
  context.fill();  
  if (isLabel) {
    // subtle stroke to separate white circle from background/lines
    context.lineWidth = 1;
    context.strokeStyle = '#d0d0d0';
    context.stroke();
  }
}

function drawLine(x1, y1, x2, y2) {
  context.beginPath();
  context.moveTo(x1, y1);
  context.lineTo(x2, y2);
  context.strokeStyle = lineColor;
  context.lineWidth = lineWidth;
  context.stroke();
}  

function draw() {
  // ensure font is set before measuring text
  context.font = 'bold ' + fontSize + 'px sans-serif';

  // 1) update positions
  for(var i = 0, l = points.length; i < l; i++) {
    var point = points[i];
    point.x += point.vx;
    point.y += point.vy;
  }

  // 2) compute radii for labeled points so collisions respect the padded size
  for(var i = 0, l = points.length; i < l; i++) {
    var point = points[i];
    if (point.char) {
      var metrics = context.measureText(point.char);
      var textWidth = metrics.width;
      // radius to fit text width or font size vertically, plus padding
      var computedRadius = Math.max(radius, Math.max(textWidth, fontSize) / 2 + labelPadding);
      point.radius = computedRadius;
    } else {
      point.radius = radius;
    }

    // check for edge collisions (bounce) using the computed radius
    if(point.x < 0 + point.radius) {
      point.x = point.radius;
      resetVelocity(point, 'x', 1);
    } else if(point.x > boundaryX - point.radius) {
      point.x = boundaryX - point.radius;
      resetVelocity(point, 'x', -1);
    }
    if(point.y < 0 + point.radius) {
      point.y = point.radius;
      resetVelocity(point, 'y', 1);
    } else if(point.y > boundaryY - point.radius) {
      point.y = boundaryY - point.radius;
      resetVelocity(point, 'y', -1);
    }
  }

  // 3) draw all connecting lines first so they appear behind circles
  for(var i = 0, l = points.length; i < l; i++) {
    var point = points[i];
    if (point.buddy) {
      drawLine(point.x, point.y, point.buddy.x, point.buddy.y);
    }
  }

  // 4) draw circles and labels on top
  for(var i = 0, l = points.length; i < l; i++) {
    var point = points[i];
    var isLabel = !!point.char;

    drawCircle(point.x, point.y, point.radius, isLabel);

    // draw letter if present
    if (point.char) {
      context.fillStyle = '#102131'; // darker fill so letter is visible over white circle
      context.fillText(point.char, point.x, point.y + 1); // slight vertical tweak
    }
  }
}

function animate() {
  context.clearRect(0, 0, boundaryX, boundaryY);
  draw();
  requestAnimationFrame(animate);
}
  </script>
  </body>
</html>
